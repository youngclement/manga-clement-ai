export function cleanUserPrompt(prompt: string): string {
  if (!prompt) return '';

  let cleaned = prompt.trim();

  cleaned = cleaned
    .replace(/[â•”â•—â•šâ•â•‘â•]/g, '')
    .replace(/\\n/g, '\n')
    .replace(/\\t/g, '\t')
    .replace(/\n{3,}/g, '\n\n')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0)
    .join('\n');

  const instructionPrefixes = [
    /^ðŸ“\s*USER\s*PROMPT[:\s]*/i,
    /^âš ï¸âš ï¸âš ï¸\s*CRITICAL[:\s]*/i,
    /^ðŸ“–\s*STORY\s*CONTINUATION[:\s]*/i,
    /^ðŸŽ¨\s*TECHNICAL\s*SPECIFICATIONS[:\s]*/i,
    /^ðŸ”ž\s*CONTENT\s*POLICY[:\s]*/i,
    /^âš ï¸\s*ENGLISH\s*TEXT\s*ACCURACY[:\s]*/i,
    /^MANGA\s*PAGE\s*GENERATION\s*REQUEST[:\s]*/i,
  ];

  instructionPrefixes.forEach(regex => {
    cleaned = cleaned.replace(regex, '');
  });

  if (cleaned.length > 500) {
    const instructionKeywords = [
      'CRITICAL', 'REQUIREMENTS', 'MUST', 'SHOULD', 'CHARACTER CONSISTENCY',
      'TEXT ACCURACY', 'PANEL LAYOUT', 'STORY CONTINUITY', 'VISUAL REFERENCE',
      'TECHNICAL SPECIFICATIONS', 'CONTENT POLICY', 'DIALOGUE', 'COMPOSITION'
    ];

    const instructionCount = instructionKeywords.reduce((count, keyword) => {
      return count + (cleaned.toUpperCase().includes(keyword) ? 1 : 0);
    }, 0);

    if (instructionCount > 5) {
      const lines = cleaned.split('\n');
      const userLines: string[] = [];

      for (const line of lines) {
        const upperLine = line.toUpperCase();
        if (
          upperLine.includes('CRITICAL') ||
          upperLine.includes('MUST') ||
          upperLine.includes('REQUIREMENTS') ||
          upperLine.includes('âš ï¸') ||
          upperLine.includes('âœ“') ||
          upperLine.includes('âœ—') ||
          upperLine.includes('STEP') ||
          upperLine.includes('CHECKLIST') ||
          line.length > 200
        ) {
          continue;
        }
        if (line.length < 200 && line.trim().length > 0) {
          userLines.push(line);
        }
      }

      if (userLines.length > 0) {
        cleaned = userLines.join('\n').trim();
      }
    }
  }

  cleaned = cleaned
    .trim()
    .replace(/\s+/g, ' ')
    .replace(/\n{3,}/g, '\n\n');

  return cleaned;
}

export function isUserProvidedPrompt(prompt: string | undefined | null): boolean {
  if (!prompt || !prompt.trim()) return false;

  const trimmed = prompt.trim();

  const autoGeneratedPatterns = [
    /^Continue the story naturally/i,
    /^ðŸ“–\s*(STORY|BATCH)\s*CONTINUATION/i,
    /^Continue the story naturally from page/i,
  ];

  for (const pattern of autoGeneratedPatterns) {
    if (pattern.test(trimmed)) {
      return false;
    }
  }

  if (trimmed.length > 500) {
    const instructionKeywords = [
      'CRITICAL', 'REQUIREMENTS', 'MUST', 'CHARACTER CONSISTENCY',
      'TEXT ACCURACY', 'PANEL LAYOUT', 'STORY CONTINUITY'
    ];

    const keywordCount = instructionKeywords.reduce((count, keyword) => {
      return count + (trimmed.toUpperCase().includes(keyword) ? 1 : 0);
    }, 0);

    if (keywordCount > 3) {
      return false;
    }
  }

  return true;
}

export function extractUserIntent(prompt: string): string {
  const cleaned = cleanUserPrompt(prompt);

  if (cleaned.length > 300) {
    const sentences = cleaned.split(/[.!?]\s+/);
    if (sentences.length > 0 && sentences[0].length < 200) {
      return sentences[0].trim();
    }

    return cleaned.substring(0, 200).trim();
  }

  return cleaned;
}
